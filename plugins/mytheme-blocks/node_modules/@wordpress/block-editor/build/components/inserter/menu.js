"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.InserterMenu = void 0;

var _element = require("@wordpress/element");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _lodash = require("lodash");

var _domScrollIntoView = _interopRequireDefault(require("dom-scroll-into-view"));

var _classnames = _interopRequireDefault(require("classnames"));

var _a11y = require("@wordpress/a11y");

var _i18n = require("@wordpress/i18n");

var _components = require("@wordpress/components");

var _blocks = require("@wordpress/blocks");

var _data = require("@wordpress/data");

var _compose = require("@wordpress/compose");

var _keycodes = require("@wordpress/keycodes");

var _url = require("@wordpress/url");

var _blockPreview = _interopRequireDefault(require("../block-preview"));

var _blockTypesList = _interopRequireDefault(require("../block-types-list"));

var _blockCard = _interopRequireDefault(require("../block-card"));

var _childBlocks = _interopRequireDefault(require("./child-blocks"));

var _inserterMenuExtension = _interopRequireDefault(require("../inserter-menu-extension"));

var _searchItems = require("./search-items");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var MAX_SUGGESTED_ITEMS = 9;

var stopKeyPropagation = function stopKeyPropagation(event) {
  return event.stopPropagation();
};

var getBlockNamespace = function getBlockNamespace(item) {
  return item.name.split('/')[0];
}; // Copied over from the Columns block. It seems like it should become part of public API.


var createBlocksFromInnerBlocksTemplate = function createBlocksFromInnerBlocksTemplate(innerBlocksTemplate) {
  return (0, _lodash.map)(innerBlocksTemplate, function (_ref) {
    var _ref2 = (0, _slicedToArray2.default)(_ref, 3),
        name = _ref2[0],
        attributes = _ref2[1],
        _ref2$ = _ref2[2],
        innerBlocks = _ref2$ === void 0 ? [] : _ref2$;

    return (0, _blocks.createBlock)(name, attributes, createBlocksFromInnerBlocksTemplate(innerBlocks));
  });
};

var InserterMenu =
/*#__PURE__*/
function (_Component) {
  (0, _inherits2.default)(InserterMenu, _Component);

  function InserterMenu() {
    var _this;

    (0, _classCallCheck2.default)(this, InserterMenu);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(InserterMenu).apply(this, arguments));
    _this.state = {
      childItems: [],
      filterValue: '',
      hoveredItem: null,
      suggestedItems: [],
      reusableItems: [],
      itemsPerCategory: {},
      itemsPerCollection: {},
      openPanels: ['suggested']
    };
    _this.onChangeSearchInput = _this.onChangeSearchInput.bind((0, _assertThisInitialized2.default)(_this));
    _this.onHover = _this.onHover.bind((0, _assertThisInitialized2.default)(_this));
    _this.panels = {};
    _this.inserterResults = (0, _element.createRef)();
    return _this;
  }

  (0, _createClass2.default)(InserterMenu, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.fetchReusableBlocks) {
        this.props.fetchReusableBlocks();
      }

      this.filter();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.items !== this.props.items) {
        this.filter(this.state.filterValue);
      }
    }
  }, {
    key: "onChangeSearchInput",
    value: function onChangeSearchInput(event) {
      this.filter(event.target.value);
    }
  }, {
    key: "onHover",
    value: function onHover(item) {
      this.setState({
        hoveredItem: item
      });
      var _this$props = this.props,
          showInsertionPoint = _this$props.showInsertionPoint,
          hideInsertionPoint = _this$props.hideInsertionPoint;

      if (item) {
        showInsertionPoint();
      } else {
        hideInsertionPoint();
      }
    }
  }, {
    key: "bindPanel",
    value: function bindPanel(name) {
      var _this2 = this;

      return function (ref) {
        _this2.panels[name] = ref;
      };
    }
  }, {
    key: "onTogglePanel",
    value: function onTogglePanel(panel) {
      var _this3 = this;

      return function () {
        var isOpened = _this3.state.openPanels.indexOf(panel) !== -1;

        if (isOpened) {
          _this3.setState({
            openPanels: (0, _lodash.without)(_this3.state.openPanels, panel)
          });
        } else {
          _this3.setState({
            openPanels: [].concat((0, _toConsumableArray2.default)(_this3.state.openPanels), [panel])
          });

          _this3.props.setTimeout(function () {
            // We need a generic way to access the panel's container
            (0, _domScrollIntoView.default)(_this3.panels[panel], _this3.inserterResults.current, {
              alignWithTop: true
            });
          });
        }
      };
    }
  }, {
    key: "filterOpenPanels",
    value: function filterOpenPanels(filterValue, itemsPerCategory, itemsPerCollection, filteredItems, reusableItems) {
      if (filterValue === this.state.filterValue) {
        return this.state.openPanels;
      }

      if (!filterValue) {
        return ['suggested'];
      }

      var openPanels = [];

      if (reusableItems.length > 0) {
        openPanels.push('reusable');
      }

      if (filteredItems.length > 0) {
        openPanels = openPanels.concat(Object.keys(itemsPerCategory), Object.keys(itemsPerCollection));
      }

      return openPanels;
    }
  }, {
    key: "filter",
    value: function filter() {
      var filterValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var _this$props2 = this.props,
          categories = _this$props2.categories,
          collections = _this$props2.collections,
          debouncedSpeak = _this$props2.debouncedSpeak,
          items = _this$props2.items,
          rootChildBlocks = _this$props2.rootChildBlocks;
      var filteredItems = (0, _searchItems.searchItems)(items, categories, collections, filterValue);
      var childItems = (0, _lodash.filter)(filteredItems, function (_ref3) {
        var name = _ref3.name;
        return (0, _lodash.includes)(rootChildBlocks, name);
      });
      var suggestedItems = [];

      if (!filterValue) {
        var maxSuggestedItems = this.props.maxSuggestedItems || MAX_SUGGESTED_ITEMS;
        suggestedItems = (0, _lodash.filter)(items, function (item) {
          return item.utility > 0;
        }).slice(0, maxSuggestedItems);
      }

      var reusableItems = (0, _lodash.filter)(filteredItems, {
        category: 'reusable'
      });

      var getCategoryIndex = function getCategoryIndex(item) {
        return (0, _lodash.findIndex)(categories, function (category) {
          return category.slug === item.category;
        });
      };

      var itemsPerCategory = (0, _lodash.flow)(function (itemList) {
        return (0, _lodash.filter)(itemList, function (item) {
          return item.category !== 'reusable';
        });
      }, function (itemList) {
        return (0, _lodash.sortBy)(itemList, getCategoryIndex);
      }, function (itemList) {
        return (0, _lodash.groupBy)(itemList, 'category');
      })(filteredItems); // Create a new Object to avoid mutating this.props.collection

      var itemsPerCollection = _objectSpread({}, collections);

      Object.keys(collections).forEach(function (namespace) {
        itemsPerCollection[namespace] = filteredItems.filter(function (item) {
          return getBlockNamespace(item) === namespace;
        });

        if (itemsPerCollection[namespace].length === 0) {
          delete itemsPerCollection[namespace];
        }
      });
      this.setState({
        hoveredItem: null,
        childItems: childItems,
        filterValue: filterValue,
        suggestedItems: suggestedItems,
        reusableItems: reusableItems,
        itemsPerCategory: itemsPerCategory,
        itemsPerCollection: itemsPerCollection,
        openPanels: this.filterOpenPanels(filterValue, itemsPerCategory, itemsPerCollection, filteredItems, reusableItems)
      });
      var resultCount = Object.keys(itemsPerCategory).reduce(function (accumulator, currentCategorySlug) {
        return accumulator + itemsPerCategory[currentCategorySlug].length;
      }, 0);
      var resultsFoundMessage = (0, _i18n.sprintf)((0, _i18n._n)('%d result found.', '%d results found.', resultCount), resultCount);
      debouncedSpeak(resultsFoundMessage);
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event) {
      if ((0, _lodash.includes)([_keycodes.LEFT, _keycodes.DOWN, _keycodes.RIGHT, _keycodes.UP, _keycodes.BACKSPACE, _keycodes.ENTER], event.keyCode)) {
        // Stop the key event from propagating up to ObserveTyping.startTypingInTextField.
        event.stopPropagation();
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var _this$props3 = this.props,
          categories = _this$props3.categories,
          collections = _this$props3.collections,
          instanceId = _this$props3.instanceId,
          onSelect = _this$props3.onSelect,
          rootClientId = _this$props3.rootClientId,
          showInserterHelpPanel = _this$props3.showInserterHelpPanel;
      var _this$state = this.state,
          childItems = _this$state.childItems,
          hoveredItem = _this$state.hoveredItem,
          itemsPerCategory = _this$state.itemsPerCategory,
          itemsPerCollection = _this$state.itemsPerCollection,
          openPanels = _this$state.openPanels,
          reusableItems = _this$state.reusableItems,
          suggestedItems = _this$state.suggestedItems,
          filterValue = _this$state.filterValue;

      var isPanelOpen = function isPanelOpen(panel) {
        return openPanels.indexOf(panel) !== -1;
      };

      var hasItems = !(0, _lodash.isEmpty)(suggestedItems) || !(0, _lodash.isEmpty)(reusableItems) || !(0, _lodash.isEmpty)(itemsPerCategory) || !(0, _lodash.isEmpty)(itemsPerCollection);
      var hoveredItemBlockType = hoveredItem ? (0, _blocks.getBlockType)(hoveredItem.name) : null;
      var hasHelpPanel = hasItems && showInserterHelpPanel; // Disable reason (no-autofocus): The inserter menu is a modal display, not one which
      // is always visible, and one which already incurs this behavior of autoFocus via
      // Popover's focusOnMount.
      // Disable reason (no-static-element-interactions): Navigational key-presses within
      // the menu are prevented from triggering WritingFlow and ObserveTyping interactions.

      /* eslint-disable jsx-a11y/no-autofocus, jsx-a11y/no-static-element-interactions */

      return (0, _element.createElement)("div", {
        className: (0, _classnames.default)('block-editor-inserter__menu', {
          'has-help-panel': hasHelpPanel
        }),
        onKeyPress: stopKeyPropagation,
        onKeyDown: this.onKeyDown
      }, (0, _element.createElement)("div", {
        className: "block-editor-inserter__main-area"
      }, (0, _element.createElement)("label", {
        htmlFor: "block-editor-inserter__search-".concat(instanceId),
        className: "screen-reader-text"
      }, (0, _i18n.__)('Search for a block')), (0, _element.createElement)("input", {
        id: "block-editor-inserter__search-".concat(instanceId),
        type: "search",
        placeholder: (0, _i18n.__)('Search for a block'),
        className: "block-editor-inserter__search",
        autoFocus: true,
        onChange: this.onChangeSearchInput
      }), (0, _element.createElement)("div", {
        className: "block-editor-inserter__results",
        ref: this.inserterResults,
        tabIndex: "0",
        role: "region",
        "aria-label": (0, _i18n.__)('Available block types')
      }, (0, _element.createElement)(_childBlocks.default, {
        rootClientId: rootClientId,
        items: childItems,
        onSelect: onSelect,
        onHover: this.onHover
      }), !!suggestedItems.length && (0, _element.createElement)(_components.PanelBody, {
        title: (0, _i18n._x)('Most used', 'blocks'),
        opened: isPanelOpen('suggested'),
        onToggle: this.onTogglePanel('suggested'),
        ref: this.bindPanel('suggested')
      }, (0, _element.createElement)(_blockTypesList.default, {
        items: suggestedItems,
        onSelect: onSelect,
        onHover: this.onHover
      })), (0, _lodash.map)(categories, function (category) {
        var categoryItems = itemsPerCategory[category.slug];

        if (!categoryItems || !categoryItems.length) {
          return null;
        }

        return (0, _element.createElement)(_components.PanelBody, {
          key: category.slug,
          title: category.title,
          icon: category.icon,
          opened: isPanelOpen(category.slug),
          onToggle: _this4.onTogglePanel(category.slug),
          ref: _this4.bindPanel(category.slug)
        }, (0, _element.createElement)(_blockTypesList.default, {
          items: categoryItems,
          onSelect: onSelect,
          onHover: _this4.onHover
        }));
      }), (0, _lodash.map)(collections, function (collection, namespace) {
        var collectionItems = itemsPerCollection[namespace];

        if (!collectionItems || !collectionItems.length) {
          return null;
        }

        return (0, _element.createElement)(_components.PanelBody, {
          key: namespace,
          title: collection.title,
          icon: collection.icon,
          opened: isPanelOpen(namespace),
          onToggle: _this4.onTogglePanel(namespace),
          ref: _this4.bindPanel(namespace)
        }, (0, _element.createElement)(_blockTypesList.default, {
          items: collectionItems,
          onSelect: onSelect,
          onHover: _this4.onHover
        }));
      }), !!reusableItems.length && (0, _element.createElement)(_components.PanelBody, {
        className: "block-editor-inserter__reusable-blocks-panel",
        title: (0, _i18n.__)('Reusable'),
        opened: isPanelOpen('reusable'),
        onToggle: this.onTogglePanel('reusable'),
        icon: "controls-repeat",
        ref: this.bindPanel('reusable')
      }, (0, _element.createElement)(_blockTypesList.default, {
        items: reusableItems,
        onSelect: onSelect,
        onHover: this.onHover
      }), (0, _element.createElement)("a", {
        className: "block-editor-inserter__manage-reusable-blocks",
        href: (0, _url.addQueryArgs)('edit.php', {
          post_type: 'wp_block'
        })
      }, (0, _i18n.__)('Manage all reusable blocks'))), (0, _element.createElement)(_inserterMenuExtension.default.Slot, {
        fillProps: {
          onSelect: onSelect,
          onHover: this.onHover,
          filterValue: filterValue,
          hasItems: hasItems
        }
      }, function (fills) {
        if (fills.length) {
          return fills;
        }

        if (!hasItems) {
          return (0, _element.createElement)("p", {
            className: "block-editor-inserter__no-results"
          }, (0, _i18n.__)('No blocks found.'));
        }

        return null;
      }))), hasHelpPanel && (0, _element.createElement)("div", {
        className: "block-editor-inserter__menu-help-panel"
      }, hoveredItem && (0, _element.createElement)(_element.Fragment, null, !(0, _blocks.isReusableBlock)(hoveredItem) && (0, _element.createElement)(_blockCard.default, {
        blockType: hoveredItem
      }), (0, _element.createElement)("div", {
        className: "block-editor-inserter__preview"
      }, (0, _blocks.isReusableBlock)(hoveredItem) || hoveredItemBlockType.example ? (0, _element.createElement)("div", {
        className: "block-editor-inserter__preview-content"
      }, (0, _element.createElement)(_blockPreview.default, {
        padding: 10,
        viewportWidth: 500,
        blocks: hoveredItemBlockType.example ? (0, _blocks.getBlockFromExample)(hoveredItem.name, {
          attributes: _objectSpread({}, hoveredItemBlockType.example.attributes, {}, hoveredItem.initialAttributes),
          innerBlocks: hoveredItemBlockType.example.innerBlocks
        }) : (0, _blocks.createBlock)(hoveredItem.name, hoveredItem.initialAttributes)
      })) : (0, _element.createElement)("div", {
        className: "block-editor-inserter__preview-content-missing"
      }, (0, _i18n.__)('No Preview Available.')))), !hoveredItem && (0, _element.createElement)("div", {
        className: "block-editor-inserter__menu-help-panel-no-block"
      }, (0, _element.createElement)("div", {
        className: "block-editor-inserter__menu-help-panel-no-block-text"
      }, (0, _element.createElement)("div", {
        className: "block-editor-inserter__menu-help-panel-title"
      }, (0, _i18n.__)('Content blocks')), (0, _element.createElement)("p", null, (0, _i18n.__)('Welcome to the wonderful world of blocks! Blocks are the basis of all content within the editor.')), (0, _element.createElement)("p", null, (0, _i18n.__)('There are blocks available for all kinds of content: insert text, headings, images, lists, videos, tables, and lots more.')), (0, _element.createElement)("p", null, (0, _i18n.__)('Browse through the library to learn more about what each block does.'))), (0, _element.createElement)(_components.Tip, null, (0, _element.__experimentalCreateInterpolateElement)((0, _i18n.__)('While writing, you can press <kbd>/</kbd> to quickly insert new blocks.'), {
        kbd: (0, _element.createElement)("kbd", null)
      })))));
      /* eslint-enable jsx-a11y/no-autofocus, jsx-a11y/no-static-element-interactions */
    }
  }]);
  return InserterMenu;
}(_element.Component);

exports.InserterMenu = InserterMenu;

var _default = (0, _compose.compose)((0, _data.withSelect)(function (select, _ref4) {
  var clientId = _ref4.clientId,
      isAppender = _ref4.isAppender,
      rootClientId = _ref4.rootClientId,
      showInserterHelpPanel = _ref4.showInserterHelpPanel;

  var _select = select('core/block-editor'),
      getInserterItems = _select.getInserterItems,
      getBlockName = _select.getBlockName,
      getBlockRootClientId = _select.getBlockRootClientId,
      getBlockSelectionEnd = _select.getBlockSelectionEnd,
      getSettings = _select.getSettings;

  var _select2 = select('core/blocks'),
      getCategories = _select2.getCategories,
      getCollections = _select2.getCollections,
      getChildBlockNames = _select2.getChildBlockNames;

  var destinationRootClientId = rootClientId;

  if (!destinationRootClientId && !clientId && !isAppender) {
    var end = getBlockSelectionEnd();

    if (end) {
      destinationRootClientId = getBlockRootClientId(end) || undefined;
    }
  }

  var destinationRootBlockName = getBlockName(destinationRootClientId);

  var _getSettings = getSettings(),
      showInserterHelpPanelSetting = _getSettings.showInserterHelpPanel,
      fetchReusableBlocks = _getSettings.__experimentalFetchReusableBlocks;

  return {
    categories: getCategories(),
    collections: getCollections(),
    rootChildBlocks: getChildBlockNames(destinationRootBlockName),
    items: getInserterItems(destinationRootClientId),
    showInserterHelpPanel: showInserterHelpPanel && showInserterHelpPanelSetting,
    destinationRootClientId: destinationRootClientId,
    fetchReusableBlocks: fetchReusableBlocks
  };
}), (0, _data.withDispatch)(function (dispatch, ownProps, _ref5) {
  var select = _ref5.select;

  var _dispatch = dispatch('core/block-editor'),
      _showInsertionPoint = _dispatch.showInsertionPoint,
      hideInsertionPoint = _dispatch.hideInsertionPoint; // To avoid duplication, getInsertionIndex is extracted and used in two event handlers
  // This breaks the withDispatch not containing any logic rule.
  // Since it's a function only called when the event handlers are called,
  // it's fine to extract it.
  // eslint-disable-next-line no-restricted-syntax


  function getInsertionIndex() {
    var _select3 = select('core/block-editor'),
        getBlockIndex = _select3.getBlockIndex,
        getBlockSelectionEnd = _select3.getBlockSelectionEnd,
        getBlockOrder = _select3.getBlockOrder;

    var clientId = ownProps.clientId,
        destinationRootClientId = ownProps.destinationRootClientId,
        isAppender = ownProps.isAppender; // If the clientId is defined, we insert at the position of the block.

    if (clientId) {
      return getBlockIndex(clientId, destinationRootClientId);
    } // If there a selected block, we insert after the selected block.


    var end = getBlockSelectionEnd();

    if (!isAppender && end) {
      return getBlockIndex(end, destinationRootClientId) + 1;
    } // Otherwise, we insert at the end of the current rootClientId


    return getBlockOrder(destinationRootClientId).length;
  }

  return {
    showInsertionPoint: function showInsertionPoint() {
      var index = getInsertionIndex();

      _showInsertionPoint(ownProps.destinationRootClientId, index);
    },
    hideInsertionPoint: hideInsertionPoint,
    onSelect: function onSelect(item) {
      var _dispatch2 = dispatch('core/block-editor'),
          replaceBlocks = _dispatch2.replaceBlocks,
          insertBlock = _dispatch2.insertBlock;

      var _select4 = select('core/block-editor'),
          getSelectedBlock = _select4.getSelectedBlock;

      var isAppender = ownProps.isAppender,
          onSelect = ownProps.onSelect,
          selectBlockOnInsert = ownProps.__experimentalSelectBlockOnInsert;
      var name = item.name,
          title = item.title,
          initialAttributes = item.initialAttributes,
          innerBlocks = item.innerBlocks;
      var selectedBlock = getSelectedBlock();
      var insertedBlock = (0, _blocks.createBlock)(name, initialAttributes, createBlocksFromInnerBlocksTemplate(innerBlocks));

      if (!isAppender && selectedBlock && (0, _blocks.isUnmodifiedDefaultBlock)(selectedBlock)) {
        replaceBlocks(selectedBlock.clientId, insertedBlock);
      } else {
        insertBlock(insertedBlock, getInsertionIndex(), ownProps.destinationRootClientId, selectBlockOnInsert);

        if (!selectBlockOnInsert) {
          // translators: %s: the name of the block that has been added
          var message = (0, _i18n.sprintf)((0, _i18n.__)('%s block added'), title);
          (0, _a11y.speak)(message);
        }
      }

      onSelect();
      return insertedBlock;
    }
  };
}), _components.withSpokenMessages, _compose.withInstanceId, _compose.withSafeTimeout)(InserterMenu);

exports.default = _default;
//# sourceMappingURL=menu.js.map