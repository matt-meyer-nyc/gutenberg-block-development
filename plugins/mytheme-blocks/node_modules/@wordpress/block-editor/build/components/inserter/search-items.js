"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.searchItems = exports.normalizeSearchTerm = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Converts the search term into a list of normalized terms.
 *
 * @param {string} term The search term to normalize.
 *
 * @return {string[]} The normalized list of search terms.
 */
var normalizeSearchTerm = function normalizeSearchTerm() {
  var term = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  // Disregard diacritics.
  //  Input: "mÃ©dia"
  term = (0, _lodash.deburr)(term); // Accommodate leading slash, matching autocomplete expectations.
  //  Input: "/media"

  term = term.replace(/^\//, ''); // Lowercase.
  //  Input: "MEDIA"

  term = term.toLowerCase(); // Extract words.

  return (0, _lodash.words)(term);
};

exports.normalizeSearchTerm = normalizeSearchTerm;

var removeMatchingTerms = function removeMatchingTerms(unmatchedTerms, unprocessedTerms) {
  return (0, _lodash.differenceWith)(unmatchedTerms, normalizeSearchTerm(unprocessedTerms), function (unmatchedTerm, unprocessedTerm) {
    return unprocessedTerm.includes(unmatchedTerm);
  });
};
/**
 * Filters an item list given a search term.
 *
 * @param {Array} items       Item list
 * @param {Array} categories  Available categories.
 * @param {Array} collections Available collections.
 * @param {string} searchTerm Search term.
 *
 * @return {Array}             Filtered item list.
 */


var searchItems = function searchItems(items, categories, collections, searchTerm) {
  var normalizedSearchTerms = normalizeSearchTerm(searchTerm);

  if (normalizedSearchTerms.length === 0) {
    return items;
  }

  return items.filter(function (_ref) {
    var name = _ref.name,
        title = _ref.title,
        category = _ref.category,
        _ref$keywords = _ref.keywords,
        keywords = _ref$keywords === void 0 ? [] : _ref$keywords,
        _ref$variations = _ref.variations,
        variations = _ref$variations === void 0 ? [] : _ref$variations;
    var unmatchedTerms = removeMatchingTerms(normalizedSearchTerms, title);

    if (unmatchedTerms.length === 0) {
      return true;
    }

    unmatchedTerms = removeMatchingTerms(unmatchedTerms, keywords.join(' '));

    if (unmatchedTerms.length === 0) {
      return true;
    }

    unmatchedTerms = removeMatchingTerms(unmatchedTerms, (0, _lodash.get)((0, _lodash.find)(categories, {
      slug: category
    }), ['title']));
    var itemCollection = collections[name.split('/')[0]];

    if (itemCollection) {
      unmatchedTerms = removeMatchingTerms(unmatchedTerms, itemCollection.title);
    }

    if (unmatchedTerms.length === 0) {
      return true;
    }

    unmatchedTerms = removeMatchingTerms(unmatchedTerms, variations.map(function (variation) {
      return variation.title;
    }).join(' '));
    return unmatchedTerms.length === 0;
  }).map(function (item) {
    if ((0, _lodash.isEmpty)(item.variations)) {
      return item;
    }

    var matchedVariations = item.variations.filter(function (variation) {
      return (0, _lodash.intersectionWith)(normalizedSearchTerms, normalizeSearchTerm(variation.title), function (termToMatch, labelTerm) {
        return labelTerm.includes(termToMatch);
      }).length > 0;
    }); // When no partterns matched, fallback to all variations.

    if ((0, _lodash.isEmpty)(matchedVariations)) {
      return item;
    }

    return _objectSpread({}, item, {
      variations: matchedVariations
    });
  });
};

exports.searchItems = searchItems;
//# sourceMappingURL=search-items.js.map