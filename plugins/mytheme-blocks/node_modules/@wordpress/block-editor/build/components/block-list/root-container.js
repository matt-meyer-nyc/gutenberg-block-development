"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.BlockNodes = exports.Context = void 0;

var _element = require("@wordpress/element");

var _data = require("@wordpress/data");

var _useMultiSelection = _interopRequireDefault(require("./use-multi-selection"));

var _dom = require("../../utils/dom");

var _insertionPoint = _interopRequireDefault(require("./insertion-point"));

var _blockPopover = _interopRequireDefault(require("./block-popover"));

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/** @typedef {import('@wordpress/element').WPSyntheticEvent} WPSyntheticEvent */
var Context = (0, _element.createContext)();
exports.Context = Context;
var BlockNodes = (0, _element.createContext)();
exports.BlockNodes = BlockNodes;

function selector(select) {
  var _select = select('core/block-editor'),
      getSelectedBlockClientId = _select.getSelectedBlockClientId,
      hasMultiSelection = _select.hasMultiSelection,
      isMultiSelecting = _select.isMultiSelecting;

  return {
    selectedBlockClientId: getSelectedBlockClientId(),
    hasMultiSelection: hasMultiSelection(),
    isMultiSelecting: isMultiSelecting()
  };
}
/**
 * Prevents default dragging behavior within a block.
 * To do: we must handle this in the future and clean up the drag target.
 * Previously dragging was prevented for multi-selected, but this is no longer
 * needed.
 *
 * @param {WPSyntheticEvent} event Synthetic drag event.
 */


function onDragStart(event) {
  // Ensure we target block content, not block controls.
  if ((0, _dom.getBlockClientId)(event.target)) {
    event.preventDefault();
  }
}

function RootContainer(_ref, ref) {
  var children = _ref.children,
      className = _ref.className,
      _ref$hasPopover = _ref.hasPopover,
      hasPopover = _ref$hasPopover === void 0 ? true : _ref$hasPopover;

  var _useSelect = (0, _data.useSelect)(selector, []),
      selectedBlockClientId = _useSelect.selectedBlockClientId,
      hasMultiSelection = _useSelect.hasMultiSelection,
      isMultiSelecting = _useSelect.isMultiSelecting;

  var _useDispatch = (0, _data.useDispatch)('core/block-editor'),
      selectBlock = _useDispatch.selectBlock;

  var onSelectionStart = (0, _useMultiSelection.default)(ref);
  /**
   * Marks the block as selected when focused and not already selected. This
   * specifically handles the case where block does not set focus on its own
   * (via `setFocus`), typically if there is no focusable input in the block.
   *
   * @param {WPSyntheticEvent} event
   */

  function onFocus(event) {
    if (hasMultiSelection) {
      return;
    }

    var clientId = (0, _dom.getBlockClientId)(event.target);

    if (clientId && clientId !== selectedBlockClientId) {
      selectBlock(clientId);
    }
  }

  return (0, _element.createElement)(_insertionPoint.default, {
    className: className,
    isMultiSelecting: isMultiSelecting,
    hasMultiSelection: hasMultiSelection,
    selectedBlockClientId: selectedBlockClientId,
    containerRef: ref
  }, (0, _element.createElement)(BlockNodes.Provider, {
    value: (0, _element.useState)({})
  }, hasPopover ? (0, _element.createElement)(_blockPopover.default, null) : null, (0, _element.createElement)("div", {
    ref: ref,
    className: className,
    onFocus: onFocus,
    onDragStart: onDragStart
  }, (0, _element.createElement)(Context.Provider, {
    value: onSelectionStart
  }, children))));
}

var _default = (0, _element.forwardRef)(RootContainer);

exports.default = _default;
//# sourceMappingURL=root-container.js.map