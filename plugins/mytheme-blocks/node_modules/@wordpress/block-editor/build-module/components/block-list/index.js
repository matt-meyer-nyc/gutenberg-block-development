import _extends from "@babel/runtime/helpers/esm/extends";
import { createElement } from "@wordpress/element";

/**
 * External dependencies
 */
import classnames from 'classnames';
/**
 * WordPress dependencies
 */

import { AsyncModeProvider, useSelect } from '@wordpress/data';
import { useRef } from '@wordpress/element';
/**
 * Internal dependencies
 */

import BlockListBlock from './block';
import BlockListAppender from '../block-list-appender';
import __experimentalBlockListFooter from '../block-list-footer';
import RootContainer from './root-container';
import useBlockDropZone from '../block-drop-zone';
/**
 * If the block count exceeds the threshold, we disable the reordering animation
 * to avoid laginess.
 */

var BLOCK_ANIMATION_THRESHOLD = 200;

var forceSyncUpdates = function forceSyncUpdates(WrappedComponent) {
  return function (props) {
    return createElement(AsyncModeProvider, {
      value: false
    }, createElement(WrappedComponent, props));
  };
};

function BlockList(_ref) {
  var className = _ref.className,
      rootClientId = _ref.rootClientId,
      isDraggable = _ref.isDraggable,
      renderAppender = _ref.renderAppender,
      _ref$__experimentalUI = _ref.__experimentalUIParts,
      __experimentalUIParts = _ref$__experimentalUI === void 0 ? {} : _ref$__experimentalUI;

  function selector(select) {
    var _select = select('core/block-editor'),
        getBlockOrder = _select.getBlockOrder,
        isMultiSelecting = _select.isMultiSelecting,
        getSelectedBlockClientId = _select.getSelectedBlockClientId,
        getMultiSelectedBlockClientIds = _select.getMultiSelectedBlockClientIds,
        hasMultiSelection = _select.hasMultiSelection,
        getGlobalBlockCount = _select.getGlobalBlockCount,
        isTyping = _select.isTyping;

    return {
      blockClientIds: getBlockOrder(rootClientId),
      isMultiSelecting: isMultiSelecting(),
      selectedBlockClientId: getSelectedBlockClientId(),
      multiSelectedBlockClientIds: getMultiSelectedBlockClientIds(),
      hasMultiSelection: hasMultiSelection(),
      enableAnimation: !isTyping() && getGlobalBlockCount() <= BLOCK_ANIMATION_THRESHOLD
    };
  }

  var _useSelect = useSelect(selector, [rootClientId]),
      blockClientIds = _useSelect.blockClientIds,
      isMultiSelecting = _useSelect.isMultiSelecting,
      selectedBlockClientId = _useSelect.selectedBlockClientId,
      multiSelectedBlockClientIds = _useSelect.multiSelectedBlockClientIds,
      hasMultiSelection = _useSelect.hasMultiSelection,
      enableAnimation = _useSelect.enableAnimation;

  var Container = rootClientId ? 'div' : RootContainer;
  var ref = useRef();
  var targetClientId = useBlockDropZone({
    element: ref,
    rootClientId: rootClientId
  });

  var __experimentalContainerProps = rootClientId ? {} : {
    hasPopover: __experimentalUIParts.hasPopover
  };

  return createElement(Container, _extends({
    ref: ref,
    className: classnames('block-editor-block-list__layout', className)
  }, __experimentalContainerProps), blockClientIds.map(function (clientId, index) {
    var isBlockInSelection = hasMultiSelection ? multiSelectedBlockClientIds.includes(clientId) : selectedBlockClientId === clientId;
    return createElement(AsyncModeProvider, {
      key: clientId,
      value: !isBlockInSelection
    }, createElement(BlockListBlock, {
      rootClientId: rootClientId,
      clientId: clientId,
      isDraggable: isDraggable,
      isMultiSelecting: isMultiSelecting // This prop is explicitely computed and passed down
      // to avoid being impacted by the async mode
      // otherwise there might be a small delay to trigger the animation.
      ,
      animateOnChange: index,
      enableAnimation: enableAnimation,
      hasSelectedUI: __experimentalUIParts.hasSelectedUI,
      className: clientId === targetClientId ? 'is-drop-target' : undefined
    }));
  }), createElement(BlockListAppender, {
    rootClientId: rootClientId,
    renderAppender: renderAppender,
    className: targetClientId === null ? 'is-drop-target' : undefined
  }), createElement(__experimentalBlockListFooter.Slot, null));
} // This component needs to always be synchronous
// as it's the one changing the async mode
// depending on the block selection.


export default forceSyncUpdates(BlockList);
//# sourceMappingURL=index.js.map