import _extends from "@babel/runtime/helpers/esm/extends";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import { createElement } from "@wordpress/element";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * External dependencies
 */
import classnames from 'classnames';
import { first, last, omit } from 'lodash';
import { animated } from 'react-spring/web.cjs';
/**
 * WordPress dependencies
 */

import { useRef, useEffect, useLayoutEffect, useState, useContext } from '@wordpress/element';
import { focus, isTextField, placeCaretAtHorizontalEdge } from '@wordpress/dom';
import { BACKSPACE, DELETE, ENTER } from '@wordpress/keycodes';
import { getBlockType, getSaveElement, isReusableBlock, isUnmodifiedDefaultBlock, getUnregisteredTypeHandlerName } from '@wordpress/blocks';
import { withFilters } from '@wordpress/components';
import { __, sprintf } from '@wordpress/i18n';
import { withDispatch, withSelect, useSelect } from '@wordpress/data';
import { withViewportMatch } from '@wordpress/viewport';
import { compose, pure, ifCondition } from '@wordpress/compose';
/**
 * Internal dependencies
 */

import BlockEdit from '../block-edit';
import BlockInvalidWarning from './block-invalid-warning';
import BlockCrashWarning from './block-crash-warning';
import BlockCrashBoundary from './block-crash-boundary';
import BlockHtml from './block-html';
import { isInsideRootBlock } from '../../utils/dom';
import useMovingAnimation from './moving-animation';
import { Context, BlockNodes } from './root-container';

function BlockListBlock(_ref) {
  var mode = _ref.mode,
      isFocusMode = _ref.isFocusMode,
      isLocked = _ref.isLocked,
      clientId = _ref.clientId,
      isSelected = _ref.isSelected,
      isMultiSelected = _ref.isMultiSelected,
      isPartOfMultiSelection = _ref.isPartOfMultiSelection,
      isFirstMultiSelected = _ref.isFirstMultiSelected,
      isLastMultiSelected = _ref.isLastMultiSelected,
      isTypingWithinBlock = _ref.isTypingWithinBlock,
      isEmptyDefaultBlock = _ref.isEmptyDefaultBlock,
      isAncestorOfSelectedBlock = _ref.isAncestorOfSelectedBlock,
      isSelectionEnabled = _ref.isSelectionEnabled,
      className = _ref.className,
      name = _ref.name,
      isValid = _ref.isValid,
      attributes = _ref.attributes,
      initialPosition = _ref.initialPosition,
      wrapperProps = _ref.wrapperProps,
      setAttributes = _ref.setAttributes,
      onReplace = _ref.onReplace,
      onInsertBlocksAfter = _ref.onInsertBlocksAfter,
      onMerge = _ref.onMerge,
      onRemove = _ref.onRemove,
      onInsertDefaultBlockAfter = _ref.onInsertDefaultBlockAfter,
      toggleSelection = _ref.toggleSelection,
      animateOnChange = _ref.animateOnChange,
      enableAnimation = _ref.enableAnimation,
      isNavigationMode = _ref.isNavigationMode,
      isMultiSelecting = _ref.isMultiSelecting,
      _ref$hasSelectedUI = _ref.hasSelectedUI,
      hasSelectedUI = _ref$hasSelectedUI === void 0 ? true : _ref$hasSelectedUI;
  var onSelectionStart = useContext(Context);

  var _useContext = useContext(BlockNodes),
      _useContext2 = _slicedToArray(_useContext, 2),
      setBlockNodes = _useContext2[1]; // In addition to withSelect, we should favor using useSelect in this component going forward
  // to avoid leaking new props to the public API (editor.BlockListBlock filter)


  var _useSelect = useSelect(function (select) {
    return {
      isDraggingBlocks: select('core/block-editor').isDraggingBlocks()
    };
  }, []),
      isDraggingBlocks = _useSelect.isDraggingBlocks; // Reference of the wrapper


  var wrapper = useRef(null); // Provide the selected node, or the first and last nodes of a multi-
  // selection, so it can be used to position the contextual block toolbar.
  // We only provide what is necessary, and remove the nodes again when they
  // are no longer selected.

  useLayoutEffect(function () {
    if (isSelected || isFirstMultiSelected || isLastMultiSelected) {
      var node = wrapper.current;
      setBlockNodes(function (nodes) {
        return _objectSpread({}, nodes, _defineProperty({}, clientId, node));
      });
      return function () {
        setBlockNodes(function (nodes) {
          return omit(nodes, clientId);
        });
      };
    }
  }, [isSelected, isFirstMultiSelected, isLastMultiSelected]); // Handling the error state

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      hasError = _useState2[0],
      setErrorState = _useState2[1];

  var onBlockError = function onBlockError() {
    return setErrorState(true);
  };

  var blockType = getBlockType(name); // translators: %s: Type of block (i.e. Text, Image etc)

  var blockLabel = sprintf(__('Block: %s'), blockType.title); // Handing the focus of the block on creation and update

  /**
   * When a block becomes selected, transition focus to an inner tabbable.
   *
   * @param {boolean} ignoreInnerBlocks Should not focus inner blocks.
   */

  var focusTabbable = function focusTabbable(ignoreInnerBlocks) {
    // Focus is captured by the wrapper node, so while focus transition
    // should only consider tabbables within editable display, since it
    // may be the wrapper itself or a side control which triggered the
    // focus event, don't unnecessary transition to an inner tabbable.
    if (wrapper.current.contains(document.activeElement)) {
      return;
    } // Find all tabbables within node.


    var textInputs = focus.tabbable.find(wrapper.current).filter(isTextField) // Exclude inner blocks
    .filter(function (node) {
      return !ignoreInnerBlocks || isInsideRootBlock(wrapper.current, node);
    }); // If reversed (e.g. merge via backspace), use the last in the set of
    // tabbables.

    var isReverse = -1 === initialPosition;
    var target = (isReverse ? last : first)(textInputs);

    if (!target) {
      wrapper.current.focus();
      return;
    }

    placeCaretAtHorizontalEdge(target, isReverse);
  }; // Focus the selected block's wrapper or inner input on mount and update


  var isMounting = useRef(true);
  useEffect(function () {
    if (!isMultiSelecting && !isNavigationMode && isSelected) {
      focusTabbable(!isMounting.current);
    }

    isMounting.current = false;
  }, [isSelected, isMultiSelecting, isNavigationMode]); // Block Reordering animation

  var animationStyle = useMovingAnimation(wrapper, isSelected || isPartOfMultiSelection, isSelected || isFirstMultiSelected, enableAnimation, animateOnChange); // Other event handlers

  /**
   * Interprets keydown event intent to remove or insert after block if key
   * event occurs on wrapper node. This can occur when the block has no text
   * fields of its own, particularly after initial insertion, to allow for
   * easy deletion and continuous writing flow to add additional content.
   *
   * @param {KeyboardEvent} event Keydown event.
   */

  var onKeyDown = function onKeyDown(event) {
    var keyCode = event.keyCode,
        target = event.target;

    switch (keyCode) {
      case ENTER:
        if (target === wrapper.current) {
          // Insert default block after current block if enter and event
          // not already handled by descendant.
          onInsertDefaultBlockAfter();
          event.preventDefault();
        }

        break;

      case BACKSPACE:
      case DELETE:
        if (target === wrapper.current) {
          // Remove block on backspace.
          onRemove(clientId);
          event.preventDefault();
        }

        break;
    }
  };

  var onMouseLeave = function onMouseLeave(_ref2) {
    var which = _ref2.which,
        buttons = _ref2.buttons;

    // The primary button must be pressed to initiate selection. Fall back
    // to `which` if the standard `buttons` property is falsy. There are
    // cases where Firefox might always set `buttons` to `0`.
    // See https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
    // See https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which
    if ((buttons || which) === 1) {
      onSelectionStart(clientId);
    }
  };

  var isUnregisteredBlock = name === getUnregisteredTypeHandlerName(); // If the block is selected and we're typing the block should not appear.
  // Empty paragraph blocks should always show up as unselected.

  var showEmptyBlockSideInserter = !isNavigationMode && isSelected && isEmptyDefaultBlock && isValid;
  var shouldAppearSelected = !isFocusMode && !showEmptyBlockSideInserter && isSelected && !isTypingWithinBlock;
  var isDragging = isDraggingBlocks && (isSelected || isPartOfMultiSelection); // Determine whether the block has props to apply to the wrapper.

  if (blockType.getEditWrapperProps) {
    wrapperProps = _objectSpread({}, wrapperProps, {}, blockType.getEditWrapperProps(attributes));
  }

  var isAligned = wrapperProps && wrapperProps['data-align']; // The wp-block className is important for editor styles.
  // Generate the wrapper class names handling the different states of the block.

  var wrapperClassName = classnames('wp-block block-editor-block-list__block', {
    'has-selected-ui': hasSelectedUI,
    'has-warning': !isValid || !!hasError || isUnregisteredBlock,
    'is-selected': shouldAppearSelected && hasSelectedUI,
    'is-multi-selected': isMultiSelected,
    'is-reusable': isReusableBlock(blockType),
    'is-dragging': isDragging,
    'is-typing': isTypingWithinBlock,
    'is-focused': isFocusMode && (isSelected || isAncestorOfSelectedBlock),
    'is-focus-mode': isFocusMode,
    'has-child-selected': isAncestorOfSelectedBlock,
    'is-block-collapsed': isAligned
  }, className);
  var blockElementId = "block-".concat(clientId); // We wrap the BlockEdit component in a div that hides it when editing in
  // HTML mode. This allows us to render all of the ancillary pieces
  // (InspectorControls, etc.) which are inside `BlockEdit` but not
  // `BlockHTML`, even in HTML mode.

  var blockEdit = createElement(BlockEdit, {
    name: name,
    isSelected: isSelected,
    attributes: attributes,
    setAttributes: setAttributes,
    insertBlocksAfter: isLocked ? undefined : onInsertBlocksAfter,
    onReplace: isLocked ? undefined : onReplace,
    mergeBlocks: isLocked ? undefined : onMerge,
    clientId: clientId,
    isSelectionEnabled: isSelectionEnabled,
    toggleSelection: toggleSelection
  }); // For aligned blocks, provide a wrapper element so the block can be
  // positioned relative to the block column. This is enabled with the
  // .is-block-content className.

  if (isAligned) {
    blockEdit = createElement("div", {
      className: "is-block-content"
    }, blockEdit);
  }

  if (mode !== 'visual') {
    blockEdit = createElement("div", {
      style: {
        display: 'none'
      }
    }, blockEdit);
  }

  return createElement(animated.div, _extends({
    id: blockElementId,
    ref: wrapper,
    className: wrapperClassName,
    "data-block": clientId,
    "data-type": name // Only allow shortcuts when a blocks is selected and not locked.
    ,
    onKeyDown: isSelected && !isLocked ? onKeyDown : undefined // Only allow selection to be started from a selected block.
    ,
    onMouseLeave: isSelected ? onMouseLeave : undefined,
    tabIndex: "0",
    "aria-label": blockLabel,
    role: "group"
  }, wrapperProps, {
    style: wrapperProps && wrapperProps.style ? _objectSpread({}, wrapperProps.style, {}, animationStyle) : animationStyle
  }), createElement(BlockCrashBoundary, {
    onError: onBlockError
  }, isValid && blockEdit, isValid && mode === 'html' && createElement(BlockHtml, {
    clientId: clientId
  }), !isValid && [createElement(BlockInvalidWarning, {
    key: "invalid-warning",
    clientId: clientId
  }), createElement("div", {
    key: "invalid-preview"
  }, getSaveElement(blockType, attributes))]), !!hasError && createElement(BlockCrashWarning, null));
}

var applyWithSelect = withSelect(function (select, _ref3) {
  var clientId = _ref3.clientId,
      rootClientId = _ref3.rootClientId,
      isLargeViewport = _ref3.isLargeViewport;

  var _select = select('core/block-editor'),
      isBlockSelected = _select.isBlockSelected,
      isAncestorMultiSelected = _select.isAncestorMultiSelected,
      isBlockMultiSelected = _select.isBlockMultiSelected,
      isFirstMultiSelectedBlock = _select.isFirstMultiSelectedBlock,
      getLastMultiSelectedBlockClientId = _select.getLastMultiSelectedBlockClientId,
      isTyping = _select.isTyping,
      getBlockMode = _select.getBlockMode,
      isSelectionEnabled = _select.isSelectionEnabled,
      getSelectedBlocksInitialCaretPosition = _select.getSelectedBlocksInitialCaretPosition,
      getSettings = _select.getSettings,
      hasSelectedInnerBlock = _select.hasSelectedInnerBlock,
      getTemplateLock = _select.getTemplateLock,
      __unstableGetBlockWithoutInnerBlocks = _select.__unstableGetBlockWithoutInnerBlocks,
      isNavigationMode = _select.isNavigationMode;

  var block = __unstableGetBlockWithoutInnerBlocks(clientId);

  var isSelected = isBlockSelected(clientId);

  var _getSettings = getSettings(),
      focusMode = _getSettings.focusMode,
      isRTL = _getSettings.isRTL;

  var templateLock = getTemplateLock(rootClientId);
  var checkDeep = true; // "ancestor" is the more appropriate label due to "deep" check

  var isAncestorOfSelectedBlock = hasSelectedInnerBlock(clientId, checkDeep); // The fallback to `{}` is a temporary fix.
  // This function should never be called when a block is not present in the state.
  // It happens now because the order in withSelect rendering is not correct.

  var _ref4 = block || {},
      name = _ref4.name,
      attributes = _ref4.attributes,
      isValid = _ref4.isValid;

  return {
    isMultiSelected: isBlockMultiSelected(clientId),
    isPartOfMultiSelection: isBlockMultiSelected(clientId) || isAncestorMultiSelected(clientId),
    isFirstMultiSelected: isFirstMultiSelectedBlock(clientId),
    isLastMultiSelected: getLastMultiSelectedBlockClientId() === clientId,
    // We only care about this prop when the block is selected
    // Thus to avoid unnecessary rerenders we avoid updating the prop if the block is not selected.
    isTypingWithinBlock: (isSelected || isAncestorOfSelectedBlock) && isTyping(),
    mode: getBlockMode(clientId),
    isSelectionEnabled: isSelectionEnabled(),
    initialPosition: isSelected ? getSelectedBlocksInitialCaretPosition() : null,
    isEmptyDefaultBlock: name && isUnmodifiedDefaultBlock({
      name: name,
      attributes: attributes
    }),
    isLocked: !!templateLock,
    isFocusMode: focusMode && isLargeViewport,
    isNavigationMode: isNavigationMode(),
    isRTL: isRTL,
    // Users of the editor.BlockListBlock filter used to be able to access the block prop
    // Ideally these blocks would rely on the clientId prop only.
    // This is kept for backward compatibility reasons.
    block: block,
    name: name,
    attributes: attributes,
    isValid: isValid,
    isSelected: isSelected,
    isAncestorOfSelectedBlock: isAncestorOfSelectedBlock
  };
});
var applyWithDispatch = withDispatch(function (dispatch, ownProps, _ref5) {
  var select = _ref5.select;

  var _dispatch = dispatch('core/block-editor'),
      updateBlockAttributes = _dispatch.updateBlockAttributes,
      insertBlocks = _dispatch.insertBlocks,
      insertDefaultBlock = _dispatch.insertDefaultBlock,
      removeBlock = _dispatch.removeBlock,
      mergeBlocks = _dispatch.mergeBlocks,
      replaceBlocks = _dispatch.replaceBlocks,
      _toggleSelection = _dispatch.toggleSelection,
      __unstableMarkLastChangeAsPersistent = _dispatch.__unstableMarkLastChangeAsPersistent;

  return {
    setAttributes: function setAttributes(newAttributes) {
      var clientId = ownProps.clientId;
      updateBlockAttributes(clientId, newAttributes);
    },
    onInsertBlocks: function onInsertBlocks(blocks, index) {
      var rootClientId = ownProps.rootClientId;
      insertBlocks(blocks, index, rootClientId);
    },
    onInsertDefaultBlockAfter: function onInsertDefaultBlockAfter() {
      var clientId = ownProps.clientId,
          rootClientId = ownProps.rootClientId;

      var _select2 = select('core/block-editor'),
          getBlockIndex = _select2.getBlockIndex;

      var index = getBlockIndex(clientId, rootClientId);
      insertDefaultBlock({}, rootClientId, index + 1);
    },
    onInsertBlocksAfter: function onInsertBlocksAfter(blocks) {
      var clientId = ownProps.clientId,
          rootClientId = ownProps.rootClientId;

      var _select3 = select('core/block-editor'),
          getBlockIndex = _select3.getBlockIndex;

      var index = getBlockIndex(clientId, rootClientId);
      insertBlocks(blocks, index + 1, rootClientId);
    },
    onRemove: function onRemove(clientId) {
      removeBlock(clientId);
    },
    onMerge: function onMerge(forward) {
      var clientId = ownProps.clientId;

      var _select4 = select('core/block-editor'),
          getPreviousBlockClientId = _select4.getPreviousBlockClientId,
          getNextBlockClientId = _select4.getNextBlockClientId;

      if (forward) {
        var nextBlockClientId = getNextBlockClientId(clientId);

        if (nextBlockClientId) {
          mergeBlocks(clientId, nextBlockClientId);
        }
      } else {
        var previousBlockClientId = getPreviousBlockClientId(clientId);

        if (previousBlockClientId) {
          mergeBlocks(previousBlockClientId, clientId);
        }
      }
    },
    onReplace: function onReplace(blocks, indexToSelect) {
      if (blocks.length && !isUnmodifiedDefaultBlock(blocks[blocks.length - 1])) {
        __unstableMarkLastChangeAsPersistent();
      }

      replaceBlocks([ownProps.clientId], blocks, indexToSelect);
    },
    toggleSelection: function toggleSelection(selectionEnabled) {
      _toggleSelection(selectionEnabled);
    }
  };
});
export default compose(pure, withViewportMatch({
  isLargeViewport: 'medium'
}), applyWithSelect, applyWithDispatch, // block is sometimes not mounted at the right time, causing it be undefined
// see issue for more info https://github.com/WordPress/gutenberg/issues/17013
ifCondition(function (_ref6) {
  var block = _ref6.block;
  return !!block;
}), withFilters('editor.BlockListBlock'))(BlockListBlock);
//# sourceMappingURL=block.js.map