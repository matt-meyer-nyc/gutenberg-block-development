import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import { createElement, Fragment } from "@wordpress/element";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * External dependencies
 */
import { filter as _filter, findIndex, flow, groupBy, isEmpty, map, sortBy, without, includes } from 'lodash';
import scrollIntoView from 'dom-scroll-into-view';
import classnames from 'classnames';
/**
 * WordPress dependencies
 */

import { speak } from '@wordpress/a11y';
import { __, _n, _x, sprintf } from '@wordpress/i18n';
import { Component, __experimentalCreateInterpolateElement, createRef } from '@wordpress/element';
import { PanelBody, withSpokenMessages, Tip } from '@wordpress/components';
import { isReusableBlock, createBlock, isUnmodifiedDefaultBlock, getBlockType, getBlockFromExample } from '@wordpress/blocks';
import { withDispatch, withSelect } from '@wordpress/data';
import { withInstanceId, compose, withSafeTimeout } from '@wordpress/compose';
import { LEFT, RIGHT, UP, DOWN, BACKSPACE, ENTER } from '@wordpress/keycodes';
import { addQueryArgs } from '@wordpress/url';
/**
 * Internal dependencies
 */

import BlockPreview from '../block-preview';
import BlockTypesList from '../block-types-list';
import BlockCard from '../block-card';
import ChildBlocks from './child-blocks';
import __experimentalInserterMenuExtension from '../inserter-menu-extension';
import { searchItems } from './search-items';
var MAX_SUGGESTED_ITEMS = 9;

var stopKeyPropagation = function stopKeyPropagation(event) {
  return event.stopPropagation();
};

var getBlockNamespace = function getBlockNamespace(item) {
  return item.name.split('/')[0];
}; // Copied over from the Columns block. It seems like it should become part of public API.


var createBlocksFromInnerBlocksTemplate = function createBlocksFromInnerBlocksTemplate(innerBlocksTemplate) {
  return map(innerBlocksTemplate, function (_ref) {
    var _ref2 = _slicedToArray(_ref, 3),
        name = _ref2[0],
        attributes = _ref2[1],
        _ref2$ = _ref2[2],
        innerBlocks = _ref2$ === void 0 ? [] : _ref2$;

    return createBlock(name, attributes, createBlocksFromInnerBlocksTemplate(innerBlocks));
  });
};

export var InserterMenu =
/*#__PURE__*/
function (_Component) {
  _inherits(InserterMenu, _Component);

  function InserterMenu() {
    var _this;

    _classCallCheck(this, InserterMenu);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(InserterMenu).apply(this, arguments));
    _this.state = {
      childItems: [],
      filterValue: '',
      hoveredItem: null,
      suggestedItems: [],
      reusableItems: [],
      itemsPerCategory: {},
      itemsPerCollection: {},
      openPanels: ['suggested']
    };
    _this.onChangeSearchInput = _this.onChangeSearchInput.bind(_assertThisInitialized(_this));
    _this.onHover = _this.onHover.bind(_assertThisInitialized(_this));
    _this.panels = {};
    _this.inserterResults = createRef();
    return _this;
  }

  _createClass(InserterMenu, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.fetchReusableBlocks) {
        this.props.fetchReusableBlocks();
      }

      this.filter();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.items !== this.props.items) {
        this.filter(this.state.filterValue);
      }
    }
  }, {
    key: "onChangeSearchInput",
    value: function onChangeSearchInput(event) {
      this.filter(event.target.value);
    }
  }, {
    key: "onHover",
    value: function onHover(item) {
      this.setState({
        hoveredItem: item
      });
      var _this$props = this.props,
          showInsertionPoint = _this$props.showInsertionPoint,
          hideInsertionPoint = _this$props.hideInsertionPoint;

      if (item) {
        showInsertionPoint();
      } else {
        hideInsertionPoint();
      }
    }
  }, {
    key: "bindPanel",
    value: function bindPanel(name) {
      var _this2 = this;

      return function (ref) {
        _this2.panels[name] = ref;
      };
    }
  }, {
    key: "onTogglePanel",
    value: function onTogglePanel(panel) {
      var _this3 = this;

      return function () {
        var isOpened = _this3.state.openPanels.indexOf(panel) !== -1;

        if (isOpened) {
          _this3.setState({
            openPanels: without(_this3.state.openPanels, panel)
          });
        } else {
          _this3.setState({
            openPanels: [].concat(_toConsumableArray(_this3.state.openPanels), [panel])
          });

          _this3.props.setTimeout(function () {
            // We need a generic way to access the panel's container
            scrollIntoView(_this3.panels[panel], _this3.inserterResults.current, {
              alignWithTop: true
            });
          });
        }
      };
    }
  }, {
    key: "filterOpenPanels",
    value: function filterOpenPanels(filterValue, itemsPerCategory, itemsPerCollection, filteredItems, reusableItems) {
      if (filterValue === this.state.filterValue) {
        return this.state.openPanels;
      }

      if (!filterValue) {
        return ['suggested'];
      }

      var openPanels = [];

      if (reusableItems.length > 0) {
        openPanels.push('reusable');
      }

      if (filteredItems.length > 0) {
        openPanels = openPanels.concat(Object.keys(itemsPerCategory), Object.keys(itemsPerCollection));
      }

      return openPanels;
    }
  }, {
    key: "filter",
    value: function filter() {
      var filterValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var _this$props2 = this.props,
          categories = _this$props2.categories,
          collections = _this$props2.collections,
          debouncedSpeak = _this$props2.debouncedSpeak,
          items = _this$props2.items,
          rootChildBlocks = _this$props2.rootChildBlocks;
      var filteredItems = searchItems(items, categories, collections, filterValue);

      var childItems = _filter(filteredItems, function (_ref3) {
        var name = _ref3.name;
        return includes(rootChildBlocks, name);
      });

      var suggestedItems = [];

      if (!filterValue) {
        var maxSuggestedItems = this.props.maxSuggestedItems || MAX_SUGGESTED_ITEMS;
        suggestedItems = _filter(items, function (item) {
          return item.utility > 0;
        }).slice(0, maxSuggestedItems);
      }

      var reusableItems = _filter(filteredItems, {
        category: 'reusable'
      });

      var getCategoryIndex = function getCategoryIndex(item) {
        return findIndex(categories, function (category) {
          return category.slug === item.category;
        });
      };

      var itemsPerCategory = flow(function (itemList) {
        return _filter(itemList, function (item) {
          return item.category !== 'reusable';
        });
      }, function (itemList) {
        return sortBy(itemList, getCategoryIndex);
      }, function (itemList) {
        return groupBy(itemList, 'category');
      })(filteredItems); // Create a new Object to avoid mutating this.props.collection

      var itemsPerCollection = _objectSpread({}, collections);

      Object.keys(collections).forEach(function (namespace) {
        itemsPerCollection[namespace] = filteredItems.filter(function (item) {
          return getBlockNamespace(item) === namespace;
        });

        if (itemsPerCollection[namespace].length === 0) {
          delete itemsPerCollection[namespace];
        }
      });
      this.setState({
        hoveredItem: null,
        childItems: childItems,
        filterValue: filterValue,
        suggestedItems: suggestedItems,
        reusableItems: reusableItems,
        itemsPerCategory: itemsPerCategory,
        itemsPerCollection: itemsPerCollection,
        openPanels: this.filterOpenPanels(filterValue, itemsPerCategory, itemsPerCollection, filteredItems, reusableItems)
      });
      var resultCount = Object.keys(itemsPerCategory).reduce(function (accumulator, currentCategorySlug) {
        return accumulator + itemsPerCategory[currentCategorySlug].length;
      }, 0);
      var resultsFoundMessage = sprintf(_n('%d result found.', '%d results found.', resultCount), resultCount);
      debouncedSpeak(resultsFoundMessage);
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event) {
      if (includes([LEFT, DOWN, RIGHT, UP, BACKSPACE, ENTER], event.keyCode)) {
        // Stop the key event from propagating up to ObserveTyping.startTypingInTextField.
        event.stopPropagation();
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var _this$props3 = this.props,
          categories = _this$props3.categories,
          collections = _this$props3.collections,
          instanceId = _this$props3.instanceId,
          onSelect = _this$props3.onSelect,
          rootClientId = _this$props3.rootClientId,
          showInserterHelpPanel = _this$props3.showInserterHelpPanel;
      var _this$state = this.state,
          childItems = _this$state.childItems,
          hoveredItem = _this$state.hoveredItem,
          itemsPerCategory = _this$state.itemsPerCategory,
          itemsPerCollection = _this$state.itemsPerCollection,
          openPanels = _this$state.openPanels,
          reusableItems = _this$state.reusableItems,
          suggestedItems = _this$state.suggestedItems,
          filterValue = _this$state.filterValue;

      var isPanelOpen = function isPanelOpen(panel) {
        return openPanels.indexOf(panel) !== -1;
      };

      var hasItems = !isEmpty(suggestedItems) || !isEmpty(reusableItems) || !isEmpty(itemsPerCategory) || !isEmpty(itemsPerCollection);
      var hoveredItemBlockType = hoveredItem ? getBlockType(hoveredItem.name) : null;
      var hasHelpPanel = hasItems && showInserterHelpPanel; // Disable reason (no-autofocus): The inserter menu is a modal display, not one which
      // is always visible, and one which already incurs this behavior of autoFocus via
      // Popover's focusOnMount.
      // Disable reason (no-static-element-interactions): Navigational key-presses within
      // the menu are prevented from triggering WritingFlow and ObserveTyping interactions.

      /* eslint-disable jsx-a11y/no-autofocus, jsx-a11y/no-static-element-interactions */

      return createElement("div", {
        className: classnames('block-editor-inserter__menu', {
          'has-help-panel': hasHelpPanel
        }),
        onKeyPress: stopKeyPropagation,
        onKeyDown: this.onKeyDown
      }, createElement("div", {
        className: "block-editor-inserter__main-area"
      }, createElement("label", {
        htmlFor: "block-editor-inserter__search-".concat(instanceId),
        className: "screen-reader-text"
      }, __('Search for a block')), createElement("input", {
        id: "block-editor-inserter__search-".concat(instanceId),
        type: "search",
        placeholder: __('Search for a block'),
        className: "block-editor-inserter__search",
        autoFocus: true,
        onChange: this.onChangeSearchInput
      }), createElement("div", {
        className: "block-editor-inserter__results",
        ref: this.inserterResults,
        tabIndex: "0",
        role: "region",
        "aria-label": __('Available block types')
      }, createElement(ChildBlocks, {
        rootClientId: rootClientId,
        items: childItems,
        onSelect: onSelect,
        onHover: this.onHover
      }), !!suggestedItems.length && createElement(PanelBody, {
        title: _x('Most used', 'blocks'),
        opened: isPanelOpen('suggested'),
        onToggle: this.onTogglePanel('suggested'),
        ref: this.bindPanel('suggested')
      }, createElement(BlockTypesList, {
        items: suggestedItems,
        onSelect: onSelect,
        onHover: this.onHover
      })), map(categories, function (category) {
        var categoryItems = itemsPerCategory[category.slug];

        if (!categoryItems || !categoryItems.length) {
          return null;
        }

        return createElement(PanelBody, {
          key: category.slug,
          title: category.title,
          icon: category.icon,
          opened: isPanelOpen(category.slug),
          onToggle: _this4.onTogglePanel(category.slug),
          ref: _this4.bindPanel(category.slug)
        }, createElement(BlockTypesList, {
          items: categoryItems,
          onSelect: onSelect,
          onHover: _this4.onHover
        }));
      }), map(collections, function (collection, namespace) {
        var collectionItems = itemsPerCollection[namespace];

        if (!collectionItems || !collectionItems.length) {
          return null;
        }

        return createElement(PanelBody, {
          key: namespace,
          title: collection.title,
          icon: collection.icon,
          opened: isPanelOpen(namespace),
          onToggle: _this4.onTogglePanel(namespace),
          ref: _this4.bindPanel(namespace)
        }, createElement(BlockTypesList, {
          items: collectionItems,
          onSelect: onSelect,
          onHover: _this4.onHover
        }));
      }), !!reusableItems.length && createElement(PanelBody, {
        className: "block-editor-inserter__reusable-blocks-panel",
        title: __('Reusable'),
        opened: isPanelOpen('reusable'),
        onToggle: this.onTogglePanel('reusable'),
        icon: "controls-repeat",
        ref: this.bindPanel('reusable')
      }, createElement(BlockTypesList, {
        items: reusableItems,
        onSelect: onSelect,
        onHover: this.onHover
      }), createElement("a", {
        className: "block-editor-inserter__manage-reusable-blocks",
        href: addQueryArgs('edit.php', {
          post_type: 'wp_block'
        })
      }, __('Manage all reusable blocks'))), createElement(__experimentalInserterMenuExtension.Slot, {
        fillProps: {
          onSelect: onSelect,
          onHover: this.onHover,
          filterValue: filterValue,
          hasItems: hasItems
        }
      }, function (fills) {
        if (fills.length) {
          return fills;
        }

        if (!hasItems) {
          return createElement("p", {
            className: "block-editor-inserter__no-results"
          }, __('No blocks found.'));
        }

        return null;
      }))), hasHelpPanel && createElement("div", {
        className: "block-editor-inserter__menu-help-panel"
      }, hoveredItem && createElement(Fragment, null, !isReusableBlock(hoveredItem) && createElement(BlockCard, {
        blockType: hoveredItem
      }), createElement("div", {
        className: "block-editor-inserter__preview"
      }, isReusableBlock(hoveredItem) || hoveredItemBlockType.example ? createElement("div", {
        className: "block-editor-inserter__preview-content"
      }, createElement(BlockPreview, {
        padding: 10,
        viewportWidth: 500,
        blocks: hoveredItemBlockType.example ? getBlockFromExample(hoveredItem.name, {
          attributes: _objectSpread({}, hoveredItemBlockType.example.attributes, {}, hoveredItem.initialAttributes),
          innerBlocks: hoveredItemBlockType.example.innerBlocks
        }) : createBlock(hoveredItem.name, hoveredItem.initialAttributes)
      })) : createElement("div", {
        className: "block-editor-inserter__preview-content-missing"
      }, __('No Preview Available.')))), !hoveredItem && createElement("div", {
        className: "block-editor-inserter__menu-help-panel-no-block"
      }, createElement("div", {
        className: "block-editor-inserter__menu-help-panel-no-block-text"
      }, createElement("div", {
        className: "block-editor-inserter__menu-help-panel-title"
      }, __('Content blocks')), createElement("p", null, __('Welcome to the wonderful world of blocks! Blocks are the basis of all content within the editor.')), createElement("p", null, __('There are blocks available for all kinds of content: insert text, headings, images, lists, videos, tables, and lots more.')), createElement("p", null, __('Browse through the library to learn more about what each block does.'))), createElement(Tip, null, __experimentalCreateInterpolateElement(__('While writing, you can press <kbd>/</kbd> to quickly insert new blocks.'), {
        kbd: createElement("kbd", null)
      })))));
      /* eslint-enable jsx-a11y/no-autofocus, jsx-a11y/no-static-element-interactions */
    }
  }]);

  return InserterMenu;
}(Component);
export default compose(withSelect(function (select, _ref4) {
  var clientId = _ref4.clientId,
      isAppender = _ref4.isAppender,
      rootClientId = _ref4.rootClientId,
      showInserterHelpPanel = _ref4.showInserterHelpPanel;

  var _select = select('core/block-editor'),
      getInserterItems = _select.getInserterItems,
      getBlockName = _select.getBlockName,
      getBlockRootClientId = _select.getBlockRootClientId,
      getBlockSelectionEnd = _select.getBlockSelectionEnd,
      getSettings = _select.getSettings;

  var _select2 = select('core/blocks'),
      getCategories = _select2.getCategories,
      getCollections = _select2.getCollections,
      getChildBlockNames = _select2.getChildBlockNames;

  var destinationRootClientId = rootClientId;

  if (!destinationRootClientId && !clientId && !isAppender) {
    var end = getBlockSelectionEnd();

    if (end) {
      destinationRootClientId = getBlockRootClientId(end) || undefined;
    }
  }

  var destinationRootBlockName = getBlockName(destinationRootClientId);

  var _getSettings = getSettings(),
      showInserterHelpPanelSetting = _getSettings.showInserterHelpPanel,
      fetchReusableBlocks = _getSettings.__experimentalFetchReusableBlocks;

  return {
    categories: getCategories(),
    collections: getCollections(),
    rootChildBlocks: getChildBlockNames(destinationRootBlockName),
    items: getInserterItems(destinationRootClientId),
    showInserterHelpPanel: showInserterHelpPanel && showInserterHelpPanelSetting,
    destinationRootClientId: destinationRootClientId,
    fetchReusableBlocks: fetchReusableBlocks
  };
}), withDispatch(function (dispatch, ownProps, _ref5) {
  var select = _ref5.select;

  var _dispatch = dispatch('core/block-editor'),
      _showInsertionPoint = _dispatch.showInsertionPoint,
      hideInsertionPoint = _dispatch.hideInsertionPoint; // To avoid duplication, getInsertionIndex is extracted and used in two event handlers
  // This breaks the withDispatch not containing any logic rule.
  // Since it's a function only called when the event handlers are called,
  // it's fine to extract it.
  // eslint-disable-next-line no-restricted-syntax


  function getInsertionIndex() {
    var _select3 = select('core/block-editor'),
        getBlockIndex = _select3.getBlockIndex,
        getBlockSelectionEnd = _select3.getBlockSelectionEnd,
        getBlockOrder = _select3.getBlockOrder;

    var clientId = ownProps.clientId,
        destinationRootClientId = ownProps.destinationRootClientId,
        isAppender = ownProps.isAppender; // If the clientId is defined, we insert at the position of the block.

    if (clientId) {
      return getBlockIndex(clientId, destinationRootClientId);
    } // If there a selected block, we insert after the selected block.


    var end = getBlockSelectionEnd();

    if (!isAppender && end) {
      return getBlockIndex(end, destinationRootClientId) + 1;
    } // Otherwise, we insert at the end of the current rootClientId


    return getBlockOrder(destinationRootClientId).length;
  }

  return {
    showInsertionPoint: function showInsertionPoint() {
      var index = getInsertionIndex();

      _showInsertionPoint(ownProps.destinationRootClientId, index);
    },
    hideInsertionPoint: hideInsertionPoint,
    onSelect: function onSelect(item) {
      var _dispatch2 = dispatch('core/block-editor'),
          replaceBlocks = _dispatch2.replaceBlocks,
          insertBlock = _dispatch2.insertBlock;

      var _select4 = select('core/block-editor'),
          getSelectedBlock = _select4.getSelectedBlock;

      var isAppender = ownProps.isAppender,
          onSelect = ownProps.onSelect,
          selectBlockOnInsert = ownProps.__experimentalSelectBlockOnInsert;
      var name = item.name,
          title = item.title,
          initialAttributes = item.initialAttributes,
          innerBlocks = item.innerBlocks;
      var selectedBlock = getSelectedBlock();
      var insertedBlock = createBlock(name, initialAttributes, createBlocksFromInnerBlocksTemplate(innerBlocks));

      if (!isAppender && selectedBlock && isUnmodifiedDefaultBlock(selectedBlock)) {
        replaceBlocks(selectedBlock.clientId, insertedBlock);
      } else {
        insertBlock(insertedBlock, getInsertionIndex(), ownProps.destinationRootClientId, selectBlockOnInsert);

        if (!selectBlockOnInsert) {
          // translators: %s: the name of the block that has been added
          var message = sprintf(__('%s block added'), title);
          speak(message);
        }
      }

      onSelect();
      return insertedBlock;
    }
  };
}), withSpokenMessages, withInstanceId, withSafeTimeout)(InserterMenu);
//# sourceMappingURL=menu.js.map